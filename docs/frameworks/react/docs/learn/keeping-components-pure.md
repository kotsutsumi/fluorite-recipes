# コンポーネントを純粋に保つ

一部の JavaScript 関数は*純粋*です。純関数は計算のみを行い、それ以外は何もしません。コンポーネントを厳密に純関数として記述することで、コードベースが成長するにつれて発生しがちな、予測不可能なバグや予期しない動作を回避できます。ただし、これらの利点を得るには、いくつかのルールに従う必要があります。

## このページで学ぶこと

- 純粋性とは何か、それによりなぜバグが減らせるのか
- 変更をレンダーフェーズの外で行い、コンポーネントを純粋に保つ方法
- Strict Mode を使用してコンポーネントの間違いを見つける方法

## 純粋性：コンポーネントとは数式のようなもの

コンピュータサイエンス（特に関数型プログラミングの世界）では、[純関数](https://wikipedia.org/wiki/Pure_function)とは以下のような特性を持つ関数です。

- **自分の仕事に集中する。** 関数が呼び出される前に存在していたオブジェクトや変数を変更しません。
- **同じ入力、同じ出力。** 同じ入力が与えられると、純関数は常に同じ結果を返すべきです。

すでに純関数の一例をご存知かもしれません：数学の数式です。

この数式を考えてみてください：`y = 2x`。

`x = 2` なら `y = 4`。常に。

`x = 3` なら `y = 6`。常に。

`x = 3` の場合、`y` は時刻や株式市場の状態によって `9` や `-1` や `2.5` になることはありません。

`y = 2x` で `x = 3` なら、`y` は常に `6` です。

これを JavaScript 関数にすると、次のようになります。

```javascript
function double(number) {
  return 2 * number;
}
```

上記の例では、`double` は**純関数**です。`3` を渡すと、常に `6` を返します。

React はこの概念を中心に設計されています。**React は、記述するすべてのコンポーネントが純関数であると想定します。** つまり、記述する React コンポーネントは、同じ入力が与えられると、常に同じ JSX を返す必要があります。

```jsx
function Recipe({ drinkers }) {
  return (
    <ol>
      <li>Boil {drinkers} cups of water.</li>
      <li>Add {drinkers} spoons of tea and {0.5 * drinkers} spoons of spice.</li>
      <li>Add {0.5 * drinkers} cups of milk to boil and sugar to taste.</li>
    </ol>
  );
}

export default function App() {
  return (
    <section>
      <h1>Spiced Chai Recipe</h1>
      <h2>For two</h2>
      <Recipe drinkers={2} />
      <h2>For a gathering</h2>
      <Recipe drinkers={4} />
    </section>
  );
}
```

`drinkers={2}` を `Recipe` に渡すと、常に `2 cups of water` を含む JSX を返します。

`drinkers={4}` を渡すと、常に `4 cups of water` を含む JSX を返します。

まるで数式のようです。

コンポーネントをレシピのように考えることができます。それに従い、調理プロセス中に新しい材料を導入しなければ、毎回同じ料理が得られます。その「料理」とは、コンポーネントが React に提供する JSX で、[レンダーするもの](/learn/render-and-commit)です。

## 副作用：意図しない（付随的な）結果

React のレンダリングプロセスは常に純粋でなければなりません。コンポーネントは JSX を*返すだけ*で、レンダリング前に存在していたオブジェクトや変数を*変更*してはなりません。そうすると、コンポーネントが不純になります！

以下は、このルールに違反するコンポーネントです。

```jsx
let guest = 0;

function Cup() {
  // 悪い例：既存の変数を変更している！
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```

このコンポーネントは、外部で宣言された `guest` 変数を読み書きしています。これは、**このコンポーネントを複数回呼び出すと、異なる JSX が生成されることを意味します！** さらに、*他の*コンポーネントが `guest` を読み取ると、それらもいつレンダーされたかによって異なる JSX を生成します！ これは予測不可能です。

数式 `y = 2x` に戻ると、今や `x = 2` であっても、`y = 4` であると信頼できません。テストが失敗し、ユーザーは困惑し、飛行機が空から落ちる可能性があります。これがどれほど混乱を招くバグにつながるかがわかるでしょう！

[`guest` を prop として渡す](/learn/passing-props-to-a-component)ことで、このコンポーネントを修正できます。

```jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}
```

これで、コンポーネントは純粋になりました。返す JSX は `guest` prop のみに依存するためです。

一般に、コンポーネントが特定の順序でレンダーされることを期待すべきではありません。`y = 2x` を `y = 5x` の前に呼び出しても後に呼び出しても関係ありません。両方の数式は互いに独立して解決されます。同様に、各コンポーネントは「自分で考える」だけで、レンダリング中に他のコンポーネントと調整したり依存したりすべきではありません。レンダリングは学校の試験のようなものです。各コンポーネントは自分で JSX を計算すべきです！

> **DEEP DIVE**
>
> ### StrictMode で不純な計算を検出する
>
> まだすべてを使用していないかもしれませんが、React には、レンダリング中に読み取ることができる 3 種類の入力があります：[props](/learn/passing-props-to-a-component)、[state](/learn/state-a-components-memory)、および [context](/learn/passing-data-deeply-with-context)。これらの入力は常に読み取り専用として扱うべきです。
>
> ユーザー入力に応答して何かを*変更*したい場合、変数に書き込むのではなく、[state をセット](/learn/state-a-components-memory)すべきです。コンポーネントのレンダリング中に既存の変数やオブジェクトを変更してはいけません。
>
> React は、開発中に各コンポーネントの関数を 2 回呼び出す「Strict Mode」を提供しています。**Strict Mode はコンポーネント関数を 2 回呼び出すことで、これらのルールを破るコンポーネントを見つけるのに役立ちます。**
>
> 元の例が「Guest #1」、「Guest #2」、および「Guest #3」の代わりに「Guest #2」、「Guest #4」、および「Guest #6」を表示した方法に注目してください。元の関数は不純だったため、2 回呼び出すと壊れました。しかし、修正された純粋なバージョンは、関数が毎回 2 回呼び出されても機能します。**純関数は計算のみを行うため、2 回呼び出しても何も変わりません。** `double(2)` を 2 回呼び出しても返されるものは変わらず、`y = 2x` を 2 回解いても `y` は変わらないのと同じです。同じ入力、同じ出力。常に。
>
> Strict Mode は本番環境では影響しないため、ユーザーにとってアプリが遅くなることはありません。Strict Mode をオプトインするには、ルートコンポーネントを `<React.StrictMode>` でラップします。一部のフレームワークはデフォルトでこれを行います。

### ローカルミューテーション：コンポーネントの小さな秘密

上記の例では、問題はレンダリング中にコンポーネントが*既存*の変数を変更したことでした。これはしばしば**「ミューテーション」**と呼ばれ、少し怖く聞こえるようにするためです。純関数は関数のスコープ外の変数や、呼び出し前に作成されたオブジェクトをミューテートしません。それらは不純になります！

ただし、**レンダリング中に作成した変数やオブジェクトを変更することは、まったく問題ありません。** この例では、`[]` 配列を作成し、それを `cups` 変数に代入してから、12 個のカップを `push` しています。

```jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaGathering() {
  let cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}
```

`cups` 変数または `[]` 配列が `TeaGathering` 関数の外で作成された場合、これは大きな問題になります！ その配列にアイテムをプッシュすることで、*既存*のオブジェクトを変更することになります。

ただし、`TeaGathering` 内の*同じレンダリング中*にそれらを作成したため、問題ありません。`TeaGathering` 外のコードは、これが起こったことを決して知りません。これは**「ローカルミューテーション」**と呼ばれます。コンポーネントの小さな秘密のようなものです。

## 副作用を引き起こす可能性がある場所

関数型プログラミングは純粋性に大きく依存していますが、*どこかで*、*何かが*変更される必要があります。それがプログラミングの要点です！ これらの変更（画面の更新、アニメーションの開始、データの変更）は**副作用**と呼ばれます。それらは「脇で」起こることであり、レンダリング中には起こりません。

React では、**副作用は通常、[イベントハンドラ](/learn/responding-to-events)内に属します。** イベントハンドラは、何らかのアクション（ボタンをクリックするなど）を実行したときに React が実行する関数です。イベントハンドラはコンポーネント*内*で定義されていますが、レンダリング*中*には実行されません！ **したがって、イベントハンドラは純粋である必要はありません。**

他のすべてのオプションを使い果たし、副作用に適したイベントハンドラが見つからない場合でも、コンポーネントの [`useEffect`](/reference/react/useEffect) 呼び出しを使用して、返された JSX にそれをアタッチできます。これにより、React は、レンダリング後、副作用が許可されたときに、それを実行するように指示されます。**ただし、このアプローチは最後の手段であるべきです。**

可能な限り、レンダリングだけでロジックを表現してみてください。これがどれほど遠くまで行けるかに驚くでしょう！

> **DEEP DIVE**
>
> ### React が純粋性を重視する理由
>
> 純関数を書くには、ある程度の習慣と規律が必要です。しかし、それは素晴らしい機会も解き放ちます。
>
> - コンポーネントは異なる環境で実行できます。例えば、サーバー上で！ 同じ入力に対して同じ結果を返すため、1 つのコンポーネントが多くのユーザーリクエストに対応できます。
> - 入力が変更されていないコンポーネントの[レンダリングをスキップ](/reference/react/memo)することで、パフォーマンスを向上させることができます。これは、純関数が常に同じ結果を返すため、キャッシュしても安全だからです。
> - 深いコンポーネントツリーのレンダリング途中でデータが変更された場合、React は時代遅れのレンダリングを完了するのに時間を無駄にすることなく、レンダリングを再開できます。純粋性により、いつでも計算を停止しても安全になります。
>
> 構築しているすべての新しい React 機能は、純粋性を利用しています。データフェッチからアニメーション、パフォーマンスまで、コンポーネントを純粋に保つことは、React パラダイムの力を解き放ちます。

## まとめ

- コンポーネントは純粋でなければなりません。つまり：
  - **自分の仕事に集中する。** レンダリング前に存在していたオブジェクトや変数を変更してはいけません。
  - **同じ入力、同じ出力。** 同じ入力が与えられると、コンポーネントは常に同じ JSX を返すべきです。
- レンダリングはいつでも発生する可能性があるため、コンポーネントは互いのレンダリング順序に依存すべきではありません。
- コンポーネントがレンダリングに使用する入力をミューテートしてはいけません。それには props、state、context が含まれます。画面を更新するには、既存のオブジェクトをミューテートするのではなく、[「state をセット」](/learn/state-a-components-memory)します。
- コンポーネントのロジックを返す JSX で表現するよう努めてください。「何かを変更」する必要がある場合は、通常、イベントハンドラでそれを行いたいでしょう。最後の手段として、`useEffect` を使用できます。
- 純関数を書くには少し練習が必要ですが、それは React パラダイムの力を解き放ちます。

---

**原文:** https://react.dev/learn/keeping-components-pure
