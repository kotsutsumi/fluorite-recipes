# state の保持とリセット

state は複数のコンポーネント間で独立しています。React は UI ツリー内の各コンポーネントの位置に基づいて、どの state がどのコンポーネントに属するか管理します。再レンダーをまたいでどのようなときに state を保持し、どのようなときにリセットするのか、制御することができます。

- React が state の保持とリセットを行うタイミング
- React にコンポーネントの state のリセットを強制する方法
- key とタイプが state の保持にどのように影響するか

## state はレンダーツリー内の位置に結びついている


React はあなたの UI のコンポーネント構造をレンダーツリーとしてビルドします。

コンポーネントに state を与えると、その state はそのコンポーネントの内部で「生存」しているように思えるかもしれません。しかし、実際には state は React の中に保持されています。React は、「レンダーツリー内でそのコンポーネントがどの位置にあるか」に基づいて、保持している各 state を正しいコンポーネントに関連付けます。

以下のコードには <Counter /> JSX タグは 1 つしかありませんが、それが 2 つの異なる位置にレンダーされています。

ツリーとしては、これは以下のように見えます。

React ツリー

これらはツリー内の別々の位置にレンダーされているため、2 つの別々のカウンタとして動作します。React を使用する上でこのような位置のことについて考える必要はめったにありませんが、React がどのように機能するかを理解することは有用です。

React では、画面上の各コンポーネントは完全に独立した state を持ちます。例えば、 コンポーネントを 2 つ横に並べてレンダーすると、それぞれが別個に、独立した  および  という state を持つことになります。

両方のカウンタをクリックしてみて、互いに影響していないことを確かめてください。

ご覧のように、カウンタのうち 1 つが更新されると、そのコンポーネントの state だけが更新されます。

state の更新

React は、同じコンポーネントをツリー内の同じ位置でレンダーしている限り、その state を保持し続けます。これを確認するため、両方のカウンタを増加させてから、“Render the second counter” のチェックボックスのチェックを外して 2 つ目のコンポーネントを削除し、再びチェックを入れて元に戻してみてください。

2 つ目のカウンタのレンダーをやめた瞬間、その state は完全に消えてしまいます。これは、React がコンポーネントを削除する際にその state も破棄するからです。

コンポーネントの削除

”Render the second counter” にチェックを入れると、2 つ目の  とその state が初期化され ( = 0)、DOM に追加されます。

コンポーネントを追加する

 は、UI ツリーの中でコンポーネントが当該位置にレンダーされ続けている間は、そのコンポーネントの state を維持します。もし削除されたり、同じ位置に別のコンポーネントがレンダーされたりすると、React は state を破棄します。

## 同じ位置の同じコンポーネントは state が保持される


この例のコードには、<Counter /> タグが 2 つあります。

チェックボックスにチェックを入れたり消したりしても、カウンタの state はリセットされません。 が  であろうと  であろうと、ルートの  コンポーネントが返す  の最初の子は常に <Counter /> だからです。

 の state を更新しても、 は同じ位置にあるためリセットされない

同じコンポーネントが同じ位置にあるので、React の観点からは同じカウンタだというわけです。

 にとって重要なのは JSX マークアップの位置ではなく UI ツリー内の位置であるということを覚えておいてください。このコンポーネントからは、 の内側と外側で、2 つの  文から 2 つの異なる <Counter /> JSX タグが返されています。

チェックボックスにチェックを入れると state がリセットされると思われるかもしれませんが、そうはなりません。これは、これらの両方の <Counter /> タグが同じ位置でレンダーされているためです。あなたの関数内で条件分岐がどのように書かれているか、React には分かりません。React に「見える」のは、返されるツリーだけです。

どちらの場合も、 コンポーネントは、<Counter /> を最初の子として持つ <div> を返します。React にとって、これら 2 つのカウンタは、「ルートの最初の子の最初の子」という、同じ「住所」を持っています。これが、あなたがどのようにロジックを構築しているかに関係なく、前回のレンダーと次のレンダーの間で React がコンポーネントを対応付ける方法なのです。

## 同じ位置の異なるコンポーネントは state をリセットする


この例では、チェックボックスにチェックを入れると、<Counter> が <p> に置き換わります。

ここでは、同じ位置で異なる種類のコンポーネントを切り替えています。最初は <div> の最初の子は  でした。それを  と入れ替えると、React は UI ツリーから  を削除し、その state を破棄します。

 が  に変わると、 は削除され、 が追加される

戻すときは、 が削除され、 が追加される

また、同じ位置で異なるコンポーネントをレンダーすると、そのサブツリー全体の state がリセットされます。これがどのように動作するかを確認するために、以下でカウンタを増やしてからチェックボックスにチェックを入れてみてください：

チェックボックスをクリックするとカウンタの state がリセットされます。 をレンダーしていることは同じでも、<div> の最初の子が  から  に変わっています。子側の  が DOM から削除されたとき、その下のツリー全体（ とその state を含む）も破棄されたのです。

 が  に変わると、 は削除され、新しい  が追加される

戻すときは  は削除され、新しい  が追加される

覚えておくべきルールとして、再レンダー間で state を維持したい場合、ツリーの構造はレンダー間で「合致」する必要があります。構造が異なる場合、React がツリーからコンポーネントを削除するときに state も破棄されてしまいます。

これがコンポーネント関数の定義をネストしてはいけない理由でもあります。

以下では、 コンポーネント関数が  の内部で定義されています。

ボタンをクリックするたびに、入力フィールドの state が消えてしまいます！ これは、 がレンダーされるたびに異なる  関数が作成されているためです。同じ位置に異なるコンポーネントをレンダーしているので、React はそれより下のすべての state をリセットします。これはバグやパフォーマンスの問題につながります。この問題を避けるために、常にコンポーネント関数はトップレベルで宣言し、定義をネストしないようにしてください。

## 同じ位置で state をリセット


デフォルトでは、React はコンポーネントが同じ位置にある間、その state を保持します。通常、これがまさにあなたが望むものであり、デフォルト動作として妥当です。しかし時には、コンポーネントの state をリセットしたい場合があります。以下の、2 人のプレーヤに交替でスコアを記録させるアプリを考えてみましょう。

現在のところ、プレーヤを変更してもスコアが保持されています。2 つの  は同じ位置に表示されるため、React は  という props が変更されただけの同一の  であると認識します。

しかし、概念的には、このアプリでは、この 2 つのカウンタは別物であるべきです。UI 上の同じ場所に表示されているにせよ、一方は Taylor のカウンタで、もう一方は Sarah のカウンタなのです。

これらを切り替えるときに state をリセットする方法は、2 つあります。

1. コンポーネントを異なる位置でレンダーする
2. `key` を使って各コンポーネントに明示的な識別子を付与する

### オプション 1：異なる位置でコンポーネントをレンダー


これら 2 つの  を互いに独立させたい場合、レンダーを 2 つの別の位置で行うことで可能です。

- 最初 `isPlayerA` は `true` です。そのため、1 番目の位置に対して `Counter` の state が保持され、2 番目は空です。
- “Next player” ボタンをクリックすると、最初の位置がクリアされ、2 番目の位置に `Counter` が入ります。

初期 state

”Next” をクリック

再び “Next” をクリック

 の state は DOM から削除されるたびに破棄されます。これがボタンをクリックするたびにカウントがリセットされる理由です。

この解決策は、同じ場所でレンダーされる独立したコンポーネントが数個しかない場合には便利です。この例では 2 つしかないので、両方を JSX 内で別々にレンダーしても大変ではありません。

### オプション 2：key で state をリセットする


コンポーネントの state をリセットする一般的な方法がもうひとつあります。

リストをレンダーする際に  を使ったのを覚えているでしょうか。key はリストのためだけのものではありません！ どんなコンポーネントでも React がそれを識別するために使用できるのです。デフォルトでは、React は親コンポーネント内での順序（「1 番目のカウンタ」「2 番目のカウンタ」）を使ってコンポーネントを区別します。しかし、 を使うことで、カウンタが単なる 1 番目のカウンタや 2 番目のカウンタではなく特定のカウンタ、例えば  のカウンタである、と React に伝えることができます。このようにして、React は  のカウンタがツリーのどこにあっても識別できるようになるのです。

この例では、2 つの <Counter /> は JSX の同じ場所にあるにもかかわらず、state を共有していません：

Taylor と Sarah を切り替えたときに state が保持されなくなりました。異なる  を指定したからです。

 を指定することで、親要素内の順序ではなく、 自体を位置に関する情報として React に使用させることができます。これにより、JSX で同じ位置にレンダーしても、React はそれらを異なるカウンタとして認識するため、state が共有されてしまうことはありません。カウンタが画面に表示されるたびに、新しい state が作成されます。カウンタが削除されるたびに、その state は破棄されます。切り替えるたびに、何度でも state がリセットされます。

key はグローバルに一意である必要はなく、親要素内での位置を指定しているだけであることを覚えておきましょう。

### key でフォームをリセットする


key を使って state をリセットすることは、フォームを扱う際に特に有用です。

このチャットアプリでは、<Chat> コンポーネントがテキスト入力フィールド用の state を持っています。

入力フィールドに何か入力してから、“Alice” または “Bob” をクリックして別の送信先を選択してみてください。<Chat> がツリーの同じ位置にレンダーされているため、入力した state が保持されたままになっていることが分かります。

多くのアプリではこれが望ましい動作でしょうが、チャットアプリでは違います！ ミスクリックのせいで既に入力したメッセージを誤った相手に送ってしまうことは避けたいでしょう。これを修正するために、 を追加します。

これにより、異なる送信先を選択したときに、 コンポーネントが、その下のツリーにあるあらゆる state も含めて最初から再作成されるようになります。React は DOM 要素についても再利用するのではなく再作成します。

これで、送信先を切り替えると常にテキストフィールドがクリアされるようになります。

#### 削除されたコンポーネントの state の保持


実際のチャットアプリでは、ユーザが以前の送信先を再度選択したときに入力欄の state を復元できるようにしたいでしょう。表示されなくなったコンポーネントの state を「生かしておく」方法はいくつかあります。

- 現在のチャットだけでなく*すべて*のチャットをレンダーしておき、CSS で残りのすべてのチャットを非表示にすることができます。チャットはツリーから削除されないため、ローカル state も保持されます。この解決策はシンプルな UI では適していますが、非表示のツリーが大きく DOM ノードがたくさん含まれている場合は非常に遅くなります。
- state を[リフトアップする](/learn/sharing-state-between-components)ことで、各送信先に対応する書きかけのメッセージを親コンポーネントで保持することができます。この方法では、重要な情報を保持しているのは親の方なので、子コンポーネントが削除されても問題ありません。これが最も一般的な解決策です。
- また、React の state に加えて別の情報源を利用することもできます。例えば、ユーザがページを誤って閉じたとしてもメッセージの下書きが保持されるようにしたいでしょう。これを実装するために、`Chat` コンポーネントが [](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) から読み込んで state を初期化し、下書きを保存するようにできます。

どの戦略を選ぶ場合でも、 とのチャットと  とのチャットは概念的には異なるものなので、現在の送信先に基づいて <Chat> ツリーに  を付与することは妥当です。

- React は、同じコンポーネントが同じ位置でレンダーされている限り、state を保持する。
- state は JSX タグに保持されるのではない。JSX を置くツリー内の位置に関連付けられている。
- 異なる key を与えることで、サブツリーの state をリセットするよう強制することができる。
- コンポーネント定義をネストさせてはいけない。さもないと state がリセットされてしまう。

#### 入力テキストの消失を修正


この例では、ボタンを押すとメッセージが表示されます。が、ボタンを押すことでどういうわけか入力欄がリセットされてしまいます。なぜこれが起こるのでしょうか？ ボタンを押しても入力テキストがリセットされないように修正してください。

問題は、 が異なる位置にレンダーされていることです。 側の分岐では、<div> の 2 番目の子としてレンダーされますが、 側の分岐では、1 番目の子としてレンダーされます。そのため各位置でのコンポーネントのタイプが変わってしまいます。1 番目の位置では  と  の間で切り替わり、2 番目の位置では  と  の間で切り替わっているわけです。React は、コンポーネントタイプが変更されるたびに state をリセットします。

最も簡単な解決策は、2 つの分岐を統合して  が常に同じ位置でレンダーされるようにすることです。

厳密に言えば、 側の分岐の <Form /> の前に  側の分岐の構造に対応する  を追加する、ということも可能です。

これで  は常に 2 番目の子になり、同じ位置にあるため state が保持されます。ただし、このアプローチは分かりづらく、誰かが  を削除してしまう危険性があるため、注意が必要です。

#### 2 つのフィールドを入れ替え


これは姓と名を入力できるフォームです。また、どちらのフィールドが最初に表示されるかを制御するチェックボックスもあります。チェックボックスにチェックを入れると “Last name” フィールドが “First name” フィールドの前に表示されるようになります。

ほぼ問題なく動作していますが、バグがあります。“First name” 欄に何か入力してからチェックボックスにチェックを入れると、テキストがいまや “Last name” になった 1 番目の入力フィールドに残ってしまいます。順序を逆にしたときに入力テキストも移動するように修正してください。

このフィールドでは、親要素内の位置を使うだけでは十分ではないようです。再レンダー間で React に state の照合を行わせる方法がありませんでしたか？

 および  の両方の分岐の <Field> コンポーネントに  を指定します。これにより、親要素内での順序が変わっても、どちらの <Field> に正しく state を「マッチ」させればいいのか、React が理解できるようになります。

#### 詳細フォームをリセット


これは、編集可能な連絡先リストです。選択された連絡先の詳細情報を編集した後に、“Save” ボタンを押して更新するか、“Reset” ボタンを押して編集を元に戻すことができます。

異なる連絡先（例えば Alice）を選択すると、state は更新されるのに、フォームには前の連絡先の詳細が表示されたままになっています。選択されている連絡先が変更されたときに、正しくフォームがリセットされるように修正してください。

 コンポーネントに ={selectedId} を指定します。これにより、連絡先を切り替えたときにフォームがリセットされるようになります。

#### 読み込み中に画像をクリア


“Next” ボタンを押すとブラウザが次の画像を読み込み始めます。ただし、同一の <img> タグを使って画像を表示しているため、このままでは次の画像が読み込まれるまで前の画像が表示されたままになります。テキストが常に画像と一致することが重要である場合、これは望ましくないかもしれません。“Next” を押した瞬間に前の画像がクリアされるように変更してください。

React に DOM を再利用させず再作成させる方法がありませんでしたか？

<img> タグに  を渡しましょう。 が変更されると、React は <img> の DOM ノードを再作成します。こうすると画像が読み込まれるたびに瞬間的に画面が白くなってしまうため、アプリ内のあらゆる画像でこれが望ましいわけではありません。しかし画像が常にテキストと対応していることを保証したい場合は、この方法が適しています。

#### リスト内の state 位置ズレを修正


このリストでは各  は、“Show email” ボタンが押されたかどうかを保持する state を持っています。Alice の “Show email” を押してから、“Show in reverse order” のチェックボックスにチェックを入れてください。すると Taylor のメール欄が展開されてしまい、一方で最下部に移動した Alice のメール欄は閉じられてしまいます。

選択中の並び順と関係なく、展開中かどうかの state がそれぞれの連絡先に関連付けられるよう、修正してください。

この例の問題は  としてインデックスを使用してしまっていたことです。

しかし state はそれぞれ特定の連絡先に関連づける必要があるはずです。

連絡先の ID を  として使用することで、問題が解決します：

state はツリー内の位置と関連付けられています。 を使うことで、表示順に依存しない、名前付きの位置情報を指定することができます。

