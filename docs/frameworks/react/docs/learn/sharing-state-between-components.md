# コンポーネント間で state を共有する

2 つのコンポーネントの state を常に同時に変更したいという場合があります。これを行うには、両方のコンポーネントから state を削除して最も近い共通の親へ移動し、そこから state を props 経由でコンポーネントへ渡します。これは  のリフトアップ (lifting state up) として知られているものであり、React コードを書く際に行う最も一般的な作業のひとつです。

- コンポーネント間で state を共有する方法
- 制御された (controlled) コンポーネントと非制御 (uncontrolled) コンポーネントとは何か

## state のリフトアップの例


以下の例では、親の  コンポーネントが 2 つの別々の  をレンダーしています。

- `Accordion`
- `Panel`
- `Panel`

各  コンポーネントには、内容を表示中かどうかを決定するブール型の  という state があります。

両方のパネルで “Show” ボタンを押してみてください。

片方のパネルのボタンを押しても、もう片方のパネルには影響しません。2 つのパネルは独立していますね。

最初は、各  の  state は  なので、どちらも折りたたまれている

どちらかの  のボタンをクリックすると、その  のみ  の state が更新される

ですが今回はこれを変更し、一度に 1 つのパネルだけが展開されるようにしたいとしましょう。この設計では、2 番目のパネルを展開すると 1 番目のパネルが折りたたまれます。どのようにして実現すればよいでしょうか？

これら 2 つのパネルを協調して動作させるためには、以下の 3 ステップで、親のコンポーネントに “state をリフトアップ” する必要があります。

1. 子コンポーネントから state を**削除**する。
2. 共通の親からハードコードされた**データを渡す**。
3. 共通の親に state を**追加**し、イベントハンドラと一緒に下に渡す。

これにより、 コンポーネントが両方の  の調整役となり、一度に一方だけを展開できるようになります。

### ステップ 1：子コンポーネントから state を削除する


 の  の制御権を親コンポーネントに与えることになります。つまり、親コンポーネントが  を  に props として渡すということです。まずは  コンポーネントから以下の行を削除してください。

代わりに、 を  の props のリストに追加します。

これで、 の親コンポーネントは  を  として渡すことで制御できます。逆に、 コンポーネントは  の値を自身で制御できなくなりました。制御が親コンポーネントに移ったのです！

### ステップ 2：共通の親からハードコードされたデータを渡す


state をリフトアップするためには、協調動作させたいすべての子コンポーネントの、最も近い共通の親コンポーネントを特定する必要があります。

- `Accordion`*（最も近い共通の親）*
- `Panel`
- `Panel`

この例では  コンポーネントが該当します。両方のパネルの上にあり、それらの props を制御できるので、現在アクティブなパネルに関する “信頼できる情報源 (source of truth)” となります。 コンポーネントからハードコードされた  の値（例えば、）を両方のパネルに渡しましょう。

 コンポーネントにハードコードされた  の値を編集してみて、画面上で起きる結果を確認してください。

### ステップ 3：共通の親に state を追加する


state をリフトアップすることで、state として格納するデータの意味が変わることがあります。

今回の場合、一度に 1 つのパネルだけがアクティブであるべきです。つまり、共通の親コンポーネントである  は、どのパネルがアクティブなのかを管理する必要があります。state 変数としては、 値の代わりに、アクティブな  のインデックスを表す数値を使うことができます。

 が 0 のときは 1 番目のパネルが、1 のときは 2 番目のパネルがアクティブになります。

どちらの  の “Show” ボタンがクリックされた場合でも、 のアクティブインデックスを変更する必要があります。 という state は  内に定義されるものであるため、 からそれを直接セットすることはできません。 コンポーネントは、 として  イベントハンドラを下に渡すことで、 コンポーネントがアコーディオンの state を変更できるように明示的に許可する必要があります：

そして  内の <button> は、クリックイベントハンドラとして props である  を使用します。

これで state のリフトアップが完了です！ state を共通の親コンポーネントに移動させることで、2 つのパネルを協調動作させられるようになりました。「表示中」フラグを 2 つ使う代わりにアクティブインデックスを使用することで、一度にアクティブなパネルが 1 つだけであることが保証されました。また、イベントハンドラを子に渡すことで、子に親の state を変更させることができました。

最初、 の  は 0 なので、最初の  が  = true を受け取る。

 の  state が 1 に変更されると、2 番目の  が  = true を受け取る。

#### 制御されたコンポーネントと非制御コンポーネント


一般的に、ローカル state を持つコンポーネントを “非制御 (uncontrolled)” であると呼びます。例えば、 という state 変数を持つ元の  コンポーネントは、パネルがアクティブかどうかに関して親が影響を与えることができないため、非制御コンポーネントです。

対照的に、重要な情報がローカル state ではなく props によって駆動されるとき、コンポーネントは “制御された (controlled)” ものと呼ばれることがあります。これにより、親コンポーネントがその振る舞いを完全に指定することができます。 を props として持つ最終的な  コンポーネントは、 コンポーネントによって制御されていることになります。

非制御コンポーネントは、設定が少なくて済むので親コンポーネントの中に入れて使用することが簡単にできます。しかし、それらを協調動作させたい場合に柔軟性がありません。制御されたコンポーネントはとても柔軟ですが、親コンポーネントが props で完全に設定してあげる必要があります。

実際には、“制御された”、“非制御” は技術用語として厳密なものではありません。各コンポーネントは通常、ローカルな state と props の両方を、混在して持つものです。しかし、コンポーネントがどう設計されるか、どんな機能を持つかについて話す際には、このような考え方が役に立つでしょう。

コンポーネントを書くときには、その中のどの情報を（props で）制御し、どの情報を（state を使うことで）制御しないのかを検討してください。しかし後で考えを変えてリファクタリングすることはいつでも可能です。

## 各 state の信頼できる唯一の情報源


React アプリケーションでは、多くのコンポーネントが自身の state を保持します。一部の state は、入力フィールドのような末梢コンポーネント（ツリーの最下部のコンポーネント）に近いところに存在します。一部の state はアプリの上部に近いところに存在することでしょう。例えば、クライアントサイドルーティングライブラリも、React の state に現在のルートを格納し、props を介して下に渡すことで実装されることが一般的です。

それぞれの state について、それを「所有」するコンポーネントを選択してください。この原則は、“信頼できる唯一の情報源 (single source of truth)” としても知られています。これは、すべての state が一箇所にまとまっているという意味ではありません。それぞれの state について、その情報を保持する特定のコンポーネントが存在すべきという意味です。コンポーネント間で共有される state は複製する代わりに、共通の親にリフトアップして、それを必要とする子に渡すようにしてください。

あなたのアプリは作業を進めるうちに変化していきます。まだそれぞれの state がどこに存在すべきか分からない間は、state を下に移動させたり、上に戻したりすることがよくあります。これは開発プロセスの一環です！

もう少し多くのコンポーネントが登場する例で実践的に感覚を理解したい場合は、 の流儀を読んでみましょう。

- 2 つのコンポーネントを協調動作させたい場合は、state を共通の親に移動する。
- 次に、その共通の親から props 経由で情報を下に渡す。
- 最後に、子が親の state を変更できるよう、イベントハンドラを下に渡す。
- コンポーネントを「制御された」（props によって駆動される）か「非制御」（state によって駆動される）かという観点で考えることが有用である。

#### 入力欄の同期


以下の 2 つの入力欄は独立しています。同期して動作するようにしましょう。片方の入力欄を編集すると、他方の入力欄も同じテキストに更新されるようにしてください。

親コンポーネントに state をリフトアップする必要があります。

 という state 変数と  ハンドラを親コンポーネントに移動させます。次に、それらを両方の  コンポーネントに props 経由で渡します。これにより、2 つの入力欄の同期が保たれます。

#### リストのフィルタリング


以下の例では、 は、テキスト入力を制御する  という独自の state を保持しています。親である  コンポーネントは項目の  を表示していますが、検索クエリが考慮されていません。

(foods, query) 関数を使って、検索クエリに従ってリストの絞り込みを行ってください。変更をテストするには、入力欄に “s” と入力すると、“Sushi”、“Shish kebab”、“Dim sum” のようにリストが絞り込まれることを確認します。

 は既に実装されておりインポートされているので、自分で書く必要はありません！

 の state と  ハンドラを  から削除し、 に移動します。その後、 および  を props として  に渡します。

 の state を  コンポーネントにリフトアップします。フィルタリング済のリストを取得するために、(foods, query) を呼び出し、それを  に渡します。これで、query の入力を変更するとリストに反映されるようになります。

