# レンダーとコミット

コンポーネントは、画面上に表示される前に React によってレンダーされる必要があります。このプロセスが踏む段階を理解すると、コードがどのように実行されるのか考える際や、コードの振る舞いを説明する際に役立ちます。

## このページで学ぶこと

- React での「レンダー」の意味
- いつ、なぜ React はコンポーネントをレンダーするのか
- 画面上にコンポーネントが表示されるステップ
- レンダーしたからといって DOM が更新されるとは限らない理由

コンポーネントが料理人として厨房に立ち、食材を調理して美味しい料理を作っている様子をイメージしてみてください。このシナリオにおいて React はウェイターです。お客様の注文を伝えて、できた料理をお客様に渡します。この UI の「注文」と「提供」のプロセスは、次の 3 つのステップからなります。

1. レンダーの**トリガ**（お客様の注文を厨房に伝える）
2. コンポーネントの**レンダー**（厨房で注文の品を料理する）
3. DOM への**コミット**（テーブルに注文の品を提供する）

![レストランにおける React の役割を示す図。React がウェイターとして、ユーザからリクエストを受け取り、コンポーネントキッチンに届け、完成した UI をユーザに提供する。](https://react.dev/images/docs/illustrations/i_render-and-commit1.png)

## ステップ 1：レンダーのトリガ

コンポーネントがレンダーされる理由には 2 つあります。

1. コンポーネントの**初回レンダー**
2. コンポーネント（またはその祖先のいずれか）の **state の更新**

### 初回レンダー

アプリが開始するときには、初回のレンダーをトリガする必要があります。フレームワークやサンドボックスは、時々このコードを隠すことがありますが、これはターゲット DOM ノードで [`createRoot`](/reference/react-dom/client/createRoot) を呼び出し、そのコンポーネントで `render` メソッドを呼び出すことで行われます。

```jsx
import Image from './Image.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'))
root.render(<Image />);
```

`root.render()` 呼び出しをコメントアウトして、コンポーネントが消えるのを見てみましょう！

### state が更新されたときの再レンダー

コンポーネントが最初にレンダーされた後、[`set` 関数](/reference/react/useState#setstate)で state を更新することで、さらなるレンダーをトリガできます。コンポーネントの state を更新すると、自動的にレンダーがキューに入ります。（これは、レストランのゲストが、最初の注文の後に、喉の渇きや空腹の状態に応じて、お茶、デザート、その他さまざまなものを注文する様子にたとえることができます。）

![state の更新がレンダーをトリガする様子を示す図](https://react.dev/images/docs/illustrations/i_render-and-commit2.png)

## ステップ 2：React がコンポーネントをレンダーする

レンダーをトリガした後、React はコンポーネントを呼び出して、画面に何を表示するかを把握します。**「レンダー」とは、React がコンポーネントを呼び出すことです。**

- **初回レンダー時には、** React はルートコンポーネントを呼び出します。
- **その後のレンダーでは、** state の更新によってレンダーがトリガされた関数コンポーネントを React が呼び出します。

このプロセスは再帰的です。更新されたコンポーネントが他のコンポーネントを返す場合、React は*そのコンポーネント*を次にレンダーし、そのコンポーネントも何かを返す場合、*そのコンポーネント*を次にレンダーします、といった具合です。このプロセスは、ネストされたコンポーネントがなくなるまで続き、React は画面に表示すべき内容を正確に把握します。

次の例では、React は `Gallery()` と `Image()` を複数回呼び出します。

```jsx
export default function Gallery() {
  return (
    <section>
      <h1>Inspiring Sculptures</h1>
      <Image />
      <Image />
      <Image />
    </section>
  );
}

function Image() {
  return (
    <img
      src="https://i.imgur.com/ZF6s192.jpg"
      alt="'Floralis Genérica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"
    />
  );
}
```

- **初回レンダー中、** React は `<section>`、`<h1>`、および 3 つの `<img>` タグの [DOM ノードを作成](https://developer.mozilla.org/docs/Web/API/Document/createElement)します。
- **再レンダー中、** React は前回のレンダーから変更されたプロパティがあるかどうかを計算します。次のステップであるコミットフェーズまで、その情報では何もしません。

> **落とし穴**
>
> レンダーは常に[純粋な計算](/learn/keeping-components-pure)である必要があります。
>
> - **同じ入力には、同じ出力。** 同じ入力が与えられた場合、コンポーネントは常に同じ JSX を返すべきです。（誰かがトマトのサラダを注文したとき、玉ねぎの入ったサラダを受け取ってはいけません！）
> - **自分のことだけを考える。** レンダー前に存在していたオブジェクトや変数を変更すべきではありません。（ある注文が、他の誰かの注文を変更してはいけません。）
>
> そうしないと、コードベースが複雑になるにつれて、混乱するバグや予測不可能な動作に遭遇する可能性があります。「Strict Mode」で開発する場合、React は各コンポーネントの関数を 2 回呼び出し、不純な関数によるミスを表面化させるのに役立ちます。

#### パフォーマンスの最適化

更新されたコンポーネント内にネストされているすべてのコンポーネントをレンダーするというデフォルトの動作は、更新されたコンポーネントがツリー内の非常に高い位置にある場合、パフォーマンスにとって最適ではありません。パフォーマンスの問題に遭遇した場合、[パフォーマンス](https://ja.react.dev/reference/react/memo)セクションで説明されているいくつかのオプトイン方法で解決できます。**早すぎる最適化はしないでください！**

## ステップ 3：React が DOM に変更をコミットする

コンポーネントをレンダー（呼び出し）した後、React は DOM を変更します。

- **初回レンダーの場合、** React は [`appendChild()`](https://developer.mozilla.org/docs/Web/API/Node/appendChild) DOM API を使用して、作成したすべての DOM ノードを画面に配置します。
- **再レンダーの場合、** React は、DOM を最新のレンダー出力と一致させるために必要な最小限の操作（レンダー中に計算されたもの！）を適用します。

**React は、レンダー間で違いがある場合にのみ DOM ノードを変更します。** たとえば、毎秒親から渡される異なる props で再レンダーされるコンポーネントがあります。`<input>` にテキストを追加して `value` を更新できますが、コンポーネントが再レンダーされてもテキストは消えないことに注意してください。

```jsx
export default function Clock({ time }) {
  return (
    <>
      <h1>{time}</h1>
      <input />
    </>
  );
}
```

これは、この最後のステップで、React が新しい `time` で `<h1>` の内容のみを更新するためです。`<input>` が JSX 内の前回と同じ場所に表示されていることがわかるため、React は `<input>` やその `value` には触れません！

## エピローグ：ブラウザのペイント

レンダリングが完了し、React が DOM を更新した後、ブラウザは画面を再ペイントします。このプロセスは「ブラウザレンダリング」として知られていますが、ドキュメント全体での混乱を避けるため、「ペイント」と呼びます。

![ブラウザが「Card 要素の静物画」をペイントしている様子](https://react.dev/images/docs/illustrations/i_browser-paint.png)

## まとめ

- React アプリの画面更新は、次の 3 つのステップで行われます。
  1. トリガ
  2. レンダー
  3. コミット
- Strict Mode を使用して、コンポーネント内のミスを見つけることができます
- レンダー結果が前回と同じ場合、React は DOM に触れません

## 次のステップ

[state はスナップショットである](/learn/state-as-a-snapshot)を読んで、React が state をどのように扱うかを学びましょう。
