# state の管理

アプリケーションが成長するにつれて、state の構成方法やコンポーネント間のデータの流れについてより計画的に考えることが重要になります。バグの一般的な原因は、冗長な、あるいは重複した state です。この章では、state を適切に構造化する方法、state 更新ロジックをメンテナンスしやすい状態に保つ方法、そして離れたコンポーネント間で state を共有する方法について学びます。

- [UI の変化を state の変化として捉える方法](/learn/reacting-to-input-with-state)
- [state を適切に構造化する方法](/learn/choosing-the-state-structure)
- [コンポーネント間で state を共有するために状態を “リフトアップ” する方法](/learn/sharing-state-between-components)
- [state が保持されるかリセットされるかを制御する方法](/learn/preserving-and-resetting-state)
- [複雑な state ロジックを関数にまとめる方法](/learn/extracting-state-logic-into-a-reducer)
- [”props の穴掘り作業” なしで情報を渡す方法](/learn/passing-data-deeply-with-context)
- [アプリの成長に合わせて state 管理をスケーリングする方法](/learn/scaling-up-with-reducer-and-context)

## state を使って入力に反応する


React を使う場合、コードから直接 UI を変更することはありません。例えば「ボタンを無効にする」、「ボタンを有効にする」、「成功メッセージを表示する」といったコマンドを書くことはありません。代わりに、コンポーネントのさまざまな視覚状態（例えば「初期状態」、「入力中状態」、「成功状態」）に対して表示したい UI を記述し、ユーザ入力に応じて state の変更をトリガします。これは、デザイナが UI を考える方法に似ています。

以下は、React を使って構築されたクイズフォームです。 という state 変数を使って、送信ボタンを有効にするか無効にするか、成功メッセージを表示するかどうかを決定していることに注目してください。

 を使って入力に反応するを読んで、state ベースの考え方でユーザ操作を扱う方法を学びましょう。

## state 構造の選択


快適に変更やデバッグが行えるコンポーネントと、常にバグの種になるコンポーネントの違いは、state をうまく構造化できているかどうかです。最も重要な原則は、state に冗長な情報や重複した情報を持たせないことです。不要な state があると、それを更新するのを忘れてすぐにバグが発生してしまいます！

例えば、このフォームには冗長な  という state 変数があります。

コンポーネントがレンダーされる際に  を計算することで、この冗長な state を削除し、コードを簡素化することができます。

これは小さな変更に見えるかもしれませんが、React アプリの多くのバグはこのようにして修正されます。

 構造の選択を読んで、バグを避けるために state の構造をどのように設計するか学びましょう。

## コンポーネント間で state を共有する


2 つのコンポーネントの state を常に同時に変更したいという場合があります。これを行うには、両方のコンポーネントから state を削除して最も近い共通の親へ移動し、そこから state を props 経由でコンポーネントへ渡します。これは  のリフトアップ (lifting state up) として知られているものであり、React コードを書く際に行う最も一般的な作業のひとつです。

この例では、一度にアクティブになるべきパネルは 1 つだけです。これを実現するには、各パネルの内部にアクティブかどうかの state を保持する代わりに、親コンポーネントが state を保持し、子コンポーネントの props を指定するようにします。

コンポーネント間で state を共有するを読んで、state をリフトアップしてコンポーネントを同期させる方法を学びましょう。

## state の保持とリセット


コンポーネントを再レンダーする際、React はツリーのどの部分を保持（および更新）し、どの部分を破棄または最初から再作成するかを決定する必要があります。大抵は React の自動的な挙動でうまくいきます。デフォルトでは、React は以前にレンダーされたコンポーネントツリーと「一致する」部分のツリーを保持します。

ただし、場合によってはこれが望ましくないことがあります。このチャットアプリでは、メッセージを入力した後に送信先を切り替えても、入力フィールドがリセットされません。これにより、ユーザが誤って間違った相手にメッセージを送信してしまうかもしれません。

例えば <Chat key={email} /> のように異なる  を渡すことでデフォルトの動作を上書きし、コンポーネントの state を強制的にリセットすることができます。これにより、送信先が異なる場合は異なる  コンポーネントであり、新しいデータ（および入力フィールドなど）で最初から再作成する必要があると React に伝えることができます。これにより、全く同じコンポーネントをレンダーしても、送信先を切り替えると入力フィールドがリセットされるようになります。

 の保持とリセットを読んで、state の寿命や制御方法について学びましょう。

## state ロジックをリデューサに抽出する


多くのイベントハンドラにまたがって state の更新コードが含まれるコンポーネントは、理解が大変になりがちです。このような場合、コンポーネントの外部に、リデューサ (reducer) と呼ばれる単一の関数を作成し、すべての state 更新ロジックを集約することができます。イベントハンドラは、ユーザの「アクション」を指定するだけでよくなるため、簡潔になります。以下ではファイルの最後にあるリデューサ関数が、各アクションに対する state の更新方法を指定しています！

 ロジックをリデューサに抽出するを読んで、リデューサ関数内にロジックを集約する方法を学びましょう。

## コンテクストで深くデータを受け渡す


通常、親コンポーネントから子コンポーネントには props を使って情報を渡します。しかし、props を多数の中間コンポーネントを経由して渡さないといけない場合や、アプリ内の多くのコンポーネントが同じ情報を必要とする場合、props の受け渡しは冗長で不便なものとなり得ます。コンテクスト (Context) を使用することで、親コンポーネントから props を明示的に渡さずとも、それ以下のツリー内の任意のコンポーネント（深さに関わらず）が情報を受け取れるようにできます。

ここでは、 コンポーネントは、最も近い  に自身のネストレベルを「尋ねる」ことで、見出しレベルを決定しています。各  は、親の  にレベルを尋ねてそれに 1 を加えることで、自分自身のレベルを把握します。すべての  は、props を渡すことなしに、それ以下のすべてのコンポーネントにコンテクストを通じて情報を提供しています。

コンテクストで深くデータを受け渡すを読んで、props を渡す代わりにコンテクストを使う方法を学びましょう。

## リデューサとコンテクストでスケールアップ


リデューサを使えば、コンポーネントの state 更新ロジックを集約することができます。コンテクストを使えば、他のコンポーネントに深く情報を渡すことができます。そしてリデューサとコンテクストを組み合わせることで、複雑な画面の state 管理ができるようになります。

このアプローチでは、複雑な state を持つ親コンポーネントが、リデューサを使って state を管理します。ツリー内の任意の深さにある他のコンポーネントは、コンテクストを介してその state を読み取ることができます。また、その state を更新するためのアクションをディスパッチすることもできます。

リデューサとコンテクストでスケールアップを読んで、アプリが成長するに従って state 管理がどのようにスケールしていくか学びましょう。

## 次のステップ


 を使って入力に反応するに進んで、この章をページごとに読み進めましょう！

もしくは、すでにこれらのトピックに詳しい場合、避難ハッチについて読んでみましょう。

