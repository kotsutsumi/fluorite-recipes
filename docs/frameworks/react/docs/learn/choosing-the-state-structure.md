# state 構造の選択

快適に変更やデバッグが行えるコンポーネントと、常にバグの種になるコンポーネントの違いは、state をうまく構造化できているかどうかです。ここでは、state 構造を考慮する際に役立つ、いくつかのヒントをご紹介します。

- 単一の state 変数と複数の state 変数の使い分け
- state の構成において避けるべきこと
- state 構造の一般的な問題を修正する方法

## state 構造の原則


state を格納するコンポーネントを作成する際に、いくつ state 変数を使うのか、データ構造をどのようにするのかについて選択を行う必要があります。最適とはいえない state 構造でも正しいプログラムを作成することは可能ではありますが、より良い選択をするために役立つ原則がいくつか存在します。

1. **関連する state をグループ化する**。2 つ以上の state 変数を常に同時に更新する場合、それらを単一の state 変数にまとめることを検討してください。
2. **state の矛盾を避ける**。state の複数部分が矛盾して互いに「衝突する」構造になっている場合、ミスが発生する余地があるということです。これを避けてください。
3. **冗長な state を避ける**。コンポーネントの props や既存の state 変数からレンダー時に何らかの情報を計算できる場合、その情報をコンポーネントの state に入れるべきではありません。
4. **state 内の重複を避ける**。同じデータが複数の state 変数間、またはネストしたオブジェクト間で重複している場合、それらを同期させることは困難です。できる限り重複を減らしてください。
5. **深くネストされた state を避ける**。深い階層構造となっている state はあまり更新しやすくありません。できる限り、state をフラットに構造化する方法を選ぶようにしてください。

これらの原則の背後にある目標は、ミスを入りこませずに state を容易に更新できるようにすることです。state から冗長で重複するデータを取り除くことで、すべての state が同期した状態を保てるようになります。これは、データベースエンジニアがバグを減らすためにデータベース構造を “正規化 (normalize)” しようとする考え方と似ています。アルバート・アインシュタインのもじりですが、「 はできる限りシンプルにすべきだ、だがシンプルすぎてもいけない」ということです。

これらの原則が実際にどのように適用されるか見てみましょう。

## 関連する state をグループ化する


ときに、単一の state 変数を使用するか、複数の state 変数を使用するかで迷うことがあるかもしれません。

こうすべきでしょうか？

それともこうでしょうか？

技術的には、どちらのアプローチを採用することも可能です。しかし 2 つの state 変数が常に一緒に変更される場合は、それらを単一の state 変数にまとめると良いでしょう。そうすれば、常に両者を同期することを忘れる心配がありません。例えば以下に、カーソルを動かすと赤い点の両方の軸の座標が更新されるという例を示します。

state をオブジェクトや配列にグループ化する別のケースとして、state の数が事前にわからない場合があります。たとえば、ユーザがカスタムフィールドを追加できるフォームがある場合に、これが有用です。

state 変数がオブジェクトの場合、1 つのフィールドだけを更新することはできず、他のフィールドも明示的にコピーする必要があることを思い出してください。たとえば、上記の例で ({ x: 100 }) とはできません。 プロパティが全くないからです！  だけを設定したい場合、({ ...position, x: 100 }) とするか、2 つの state 変数に分割して (100) とするかのどちらかになります。

## state の矛盾を避ける


以下は、 と  という state 変数があるホテルのフィードバックフォームです。

このコードは機能しますが、「ありえない」state になってしまう余地を残しています。たとえば、 と  を一緒に呼び出すのを忘れた場合、 と  が同時に  になってしまう状況に陥るかもしれません。コンポーネントが複雑になればなるほど、何が起こったのか理解しにくくなります。

 と  は同時に  になることはないため、それらを 1 つの  という state 変数に置き換えて、（初期状態）、、 という 3 つの有効な状態のうちの 1 つになるようにする方が良いでしょう。

読みやすくしたければ定数を宣言することはいつでも可能です。

これらは state 変数ではなくなったので、互いに同期がとれなくなる心配をする必要はありません。

## 冗長な state を避ける


レンダー中にコンポーネントの props や既存の state 変数から情報を計算できる場合、その情報をコンポーネントの state に入れるべきではありません。

例として、このフォームを見てみましょう。動作はしていますが、冗長な state がないか探してみてください。

このフォームには 3 つの state 変数があります。、、そして  です。しかし、 は冗長です。レンダー中に  は常に  と  から計算できるので、state から削除しましょう。

以下のようにします。

これで  は  変数ではなくなっています。代わりに、レンダー中に計算されます：

結果的に、これを更新するために change ハンドラは何も特別なことをする必要がなくなりました。 や  を呼び出すと、再レンダーがトリガされ、次の  は新しいデータから計算し直されます。

#### props を state にコピーしない


冗長な state の一般的な例として、このようなコードがあります：

ここでは、 という state 変数が props である  の値で初期化されています。問題は、親コンポーネントが後で異なる  値（例えば 'blue' から 'red'）を渡してきた場合、 変数である  の方は更新されないということです！ state は最初のレンダー時にのみ初期化されます。

これが、props を state 変数に「コピー」することが混乱を招く理由です。代わりに、 をコードで直接使用してください。短い名前にしたい場合は、定数を使用してください：

これにより、親コンポーネントから渡された props と同期されなくなってしまうことを防げます。

props を state に「コピー」することが意味を持つのは、特定の props のすべての更新を意図的に無視したい場合だけです。慣習として、新しい値が来ても無視されるということを明確にしたい場合は、props の名前を  または  で始めるようにします。

## state 内の重複を避ける


このメニューリストコンポーネントでは、旅行に持っていくお菓子を複数の選択肢から 1 つだけ選ぶことができます。

現在、選択した項目を  という state 変数にオブジェクトとして格納しています。しかしこれは良くありません。なぜなら、 の内容は、 リスト内の要素のうちの 1 つと同一のオブジェクトになっているためです。これは、その項目に関する情報が 2 つの場所で重複していることを意味します。

なぜこれが問題なのでしょうか? それぞれの項目を編集可能にしてみましょう。

いずれかの項目の “Choose” をクリックしてから編集すると、入力欄は更新されますが、下部のラベルは編集内容を反映していません。これは、state に重複があり、 側の更新を忘れたためです。

 側も更新するようにしても良いのですが、簡単な解決策は重複を解消することです。この例では、 内のオブジェクトと  オブジェクトを重複させる代わりに、state では  を保持するようにし、その ID を持つアイテムを  配列から検索することで  を取得するようにします。

以前は state がこのように重複していました。

- `items = [{ id: 0, title: 'pretzels'}, ...]`
- `selectedItem = {id: 0, title: 'pretzels'}`

しかし、変更後は以下のようになります。

- `items = [{ id: 0, title: 'pretzels'}, ...]`
- `selectedId = 0`

重複がなくなり、必要な state だけが残っています！

これで、選択された項目を編集すると、下のメッセージもすぐに更新されるようになります。これは、 が再レンダーをトリガし、.find(...) がタイトル更新後の項目を見つけてくるためです。選択された項目のデータ全体を state に格納する必要はありませんでした。なぜなら選択された項目 ID だけが本質的なものだからです。残りはレンダー時に計算することができます。

## 深くネストされた state を避ける


惑星、大陸、国々で構成される旅行計画を想像してみてください。以下のようにして、state をネストしたオブジェクトと配列を駆使して構造化することが魅力的に思えるかもしれません。

ここで、既に訪れた場所を削除するボタンを追加したくなったとしましょう。どのようにすればよいでしょうか？ ネストされた state を更新すると、変更された部分より上のすべてのオブジェクトのコピーを作成する必要が出てきます。深くネストされたところにある場所情報を削除するためには、親として繋がっている場所データをすべてコピーする必要があります。そのようなコードを書くのはとても大変です。

 が簡単に更新できないほどネストしている場合は、「フラット」にすることを検討してください。ここでは、データを再構築する方法の 1 つを示します。 のそれぞれに子となる場所情報そのものの配列を持たせるのではなく、それぞれの場所が子となる場所情報の ID の配列を持つようにします。次に、それぞれの場所 ID と対応する場所情報のマッピングを格納します。

このようなデータ再構成を見ると、データベーステーブルを思い出すかもしれませんね。

 が「フラット」な（別名「正規化された (normalized)」）状態になったので、ネストされた項目の更新が簡単になります。

場所を削除したい場合、state を 2 レベルにわたって更新するだけで済みます。

- *親*の場所情報を更新して、`childIds` 配列から、削除された場所の ID を除外する。
- ルートの「テーブル」オブジェクトを更新して、上記の更新された親の場所情報を含むようにする。

以下がやり方の一例です。

state は好きなだけネストさせることができますが、「フラット」にすることで多くの問題を解決できます。state の更新が容易になるだけでなく、ネストされたオブジェクトのさまざまな部分で重複がないことを保証するのにも役立ちます。

#### メモリ使用量の改善


理想的には、削除された場所アイテム（およびその子アイテム！）自体も「テーブル」オブジェクトから削除して、メモリ使用量を改善するとよいでしょう。以下のバージョンはそれを行うものです。また、アップデートロジックをより簡潔にするために  を使用しています。

ネストされている state の一部を子コンポーネントに移動することで、state のネストを減らすことが可能な場合もあります。これは「アイテムがホバーされているか」といった、保存する必要のない一時的な UI 関連の state で適しています。

- 2 つの state 変数が常に一緒に更新される場合は、それらを 1 つにまとめることを検討する。
- 「ありえない」state を作成しないよう、state 変数を注意深く選択する。
- state は、更新時に間違いが発生しづらいやり方で構成する。
- 冗長で重複した state を避け、同期する必要がないようにする。
- 意図的に更新されないようにしたい場合を除き、props を state にコピーしない。
- 項目選択のような UI パターンにおいては、state にオブジェクト自体ではなく ID またはインデックスを保持する。
- 深くネストされた state の更新が複雑な場合は、フラット化を試す。

#### 更新されないコンポーネントの修正


この  コンポーネントは、 と  の 2 つの props を受け取ります。セレクトボックスで別の色を選択すると、 コンポーネントは親コンポーネントから props として異なる  を受け取るようになっています。しかし、何らかの理由で表示される色が更新されません。なぜでしょうか？ 問題を修正してください。

この問題は、このコンポーネントが  という state を  という props の初期値を使って初期化していることが原因です。しかし、props としての  が変更されても state 変数の方は影響されません！ それらが同期されなくなってしまっているわけです。この問題を解決するには state 変数自体を削除し、props としての  を直接使用します。

または分割代入構文を使用して以下のようにします。

#### 壊れた荷物リストの修正


この荷物 (packing) リストには、梱包済みアイテム数と全体のアイテム数を表示するフッタがあります。最初はうまく機能するように見えますが、バグがあります。例えば、アイテムに梱包済みとマークしてから削除しても、カウンタが正しく更新されません。カウンタが常に正確になるように修正してください。

この例の state のどれかは冗長ではないでしょうか？

それぞれのイベントハンドラを注意深く書き換えて  と  カウンタが正しく更新されるようにすることも可能ですが、根本的な問題は、そもそもこれらの state 変数が存在しているということです。 配列自体からアイテム数（梱包済み・合計のいずれも）は常に計算できるので、そもそもこれらは不要です。冗長な state を削除してバグを修正しましょう。

この変更により、それぞれのイベントハンドラは  を呼び出すことだけを考えればよくなったことに注目しましょう。アイテム数は次のレンダー時に  から計算されるため、常に最新情報が表示されます。

#### 選択項目が消える問題を修正


手紙のリストである  が state に保持されています。手紙のどれかにホバーまたはフォーカスすると、その手紙がハイライトされるようになっています。現在ハイライト中の手紙は、 という state 変数に格納されています。個々の手紙に対して “Star” や “Unstar”（スター解除）ができ、それにより state である  配列が更新されます。

機能はしていますが、このコードには小さな UI の不具合があります。“Star” や “Unstar” を押すと、一瞬だけハイライトが消えてしまうのです。ただしポインタを動かすか、キーボードで別の手紙に切り替えるとすぐにハイライトは再表示されます。なぜこれが起こるのでしょうか？ ボタンクリック後にハイライトが消えないように修正してください。

問題は、 に手紙オブジェクトを保持していることです。しかし同じ情報を  配列にも保持しています。つまり state に重複があるのです！ ボタンクリックに応じて  配列を更新する際に、 とは異なる新しい手紙データオブジェクトが作成されます。これが、 === letter チェックが  になってハイライトが消えてしまう理由です。次にポインタが移動して  が呼び出されるとハイライトは再表示されます。

この問題を解決するには、state から重複を削除します。2 つの場所でその手紙データ自体を格納する代わりに、 を格納するようにします。これにより、.id === highlightedId とすることで、前回のレンダーから  オブジェクトが変更された場合でも、各手紙の  をチェックできます。

#### 複数選択を実装


この例では、各 （手紙）に props として、それが選択中かという情報である  と  ハンドラが渡されています。機能していますが、state が （ または ID のどちらか）という形で格納されているため、一度に 1 つの手紙しか選択できません。

state 構造を変更し、複数選択に対応させてください。（どのように構造化しますか？ コードを書く前に考えてみてください。）各チェックボックスは他のチェックボックスとは独立して動作するようにしてください。選択中の手紙をクリックすると、チェックが外れるようにしてください。最後に、フッタに選択された項目数が正しく表示されるようにしてください。

単一の選択中 ID の代わりに、選択された ID の配列または  を state に保持することができます。

1 つの  の代わりに、state で  という配列を保持するようにします。例えば、最初と最後の手紙を選択したときに [0, 2] となるようにします。何も選択されていない場合は、空の [] という配列になります。

配列を使うことの小さな欠点の 1 つは、項目ごとに .includes(letter.id) を呼び出して選択中かどうかを確認していることです。配列が非常に大きい場合 () での配列検索にはリニアに時間がかかり、またこの検索は個々の項目ごとに行われているため、パフォーマンスの問題になることがあります。

これを解決するためには、代わりに state で  を保持するようにできます。Set には高速な () 操作があります。

これで、各アイテムは .has(letter.id) というチェックを行うため、非常に高速になります。

state 内のオブジェクトはミューテーションしないように注意してください。これには Set も含まれます。そのため、 関数ではまず Set のコピーを作成し、そのコピーを書き換えています。

