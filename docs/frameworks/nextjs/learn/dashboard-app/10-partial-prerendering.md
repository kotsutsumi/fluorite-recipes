# 第10章

# 部分的プリレンダリング

これまで、静的レンダリングと動的レンダリング、そしてデータに依存する動的コンテンツのストリーミングについて学習しました。この章では、部分的プリレンダリング（PPR）を使用して、同じルート内で静的レンダリング、動的レンダリング、ストリーミングを組み合わせる方法を学習しましょう。

> **注意**
>
> 部分的プリレンダリングは、Next.js 14で導入された実験的機能です。この機能の安定性が向上するにつれて、このページの内容は更新される可能性があります。PPRはNext.jsのcanaryリリース（`next@canary`）でのみ利用可能で、Next.jsの安定版では利用できません。本番環境での部分的プリレンダリングの使用はまだ推奨されていません。

Next.jsのcanaryリリースをインストールするには、以下のコマンドを実行してください：

```bash
pnpm install next@canary
```

## この章で扱う内容

- 部分的プリレンダリングとは何か
- 部分的プリレンダリングの仕組み

## 静的ルート vs 動的ルート

今日構築されるほとんどのWebアプリケーションでは、アプリケーション全体または特定のルートに対して、静的レンダリングと動的レンダリングのどちらかを選択します。Next.jsでは、ルート内で[動的関数](https://nextjs.org/docs/app/building-your-application/routing/route-handlers#dynamic-functions)（データベースへのクエリなど）を呼び出すと、そのルート全体が動的になります。

しかし、ほとんどのルートは完全に静的でも動的でもありません。例えば、[eコマースサイト](https://partialprerendering.com/)を考えてみましょう。商品情報ページの大部分を静的にレンダリングしたいが、ユーザーのカートやおすすめ商品は動的に取得したい場合があります。これにより、ユーザーにパーソナライズされたコンテンツを表示できます。

ダッシュボードページに戻って、どのコンポーネントが静的で、どれが動的かを考えてみてください。

準備ができたら、以下のボタンをクリックして、ダッシュボードルートをどのように分割するかを確認してください：

## 部分的プリレンダリングとは何か？

Next.js 14では、部分的プリレンダリングの実験版が導入されました。これは、同じルート内で静的レンダリングと動的レンダリングの利点を組み合わせることができる新しいレンダリングモデルです。例えば：

ユーザーがルートにアクセスすると：

- ナビゲーションバーや商品情報を含む静的ルートシェルが提供され、高速な初期読み込みが保証されます
- シェルには、カートやおすすめ商品などの動的コンテンツが非同期で読み込まれる「穴」が残されます
- 非同期の穴は並列でストリーミングされ、ページの全体的な読み込み時間を短縮します

## 部分的プリレンダリングの仕組み

部分的プリレンダリングは、React の [Suspense](https://react.dev/reference/react/Suspense)（前の章で学習した）を使用して、何らかの条件が満たされるまで（例：データが読み込まれる）アプリケーションの一部のレンダリングを遅延させます。

Suspenseフォールバックは、静的コンテンツと共に初期HTMLファイルに埋め込まれます。ビルド時（または再検証時）に、静的コンテンツがプリレンダリングされて静的シェルが作成されます。動的コンテンツのレンダリングは、ユーザーがルートをリクエストするまで延期されます。

コンポーネントをSuspenseでラップしても、そのコンポーネント自体が動的になるわけではありません。むしろ、Suspenseは静的コードと動的コードの境界として使用されます。

ダッシュボードルートでPPRを実装する方法を見てみましょう。

## 部分的プリレンダリングの実装

`next.config.ts`ファイルに[ppr](https://rc.nextjs.org/docs/app/api-reference/next-config-js/ppr)オプションを追加して、Next.jsアプリでPPRを有効にします：

```typescript
// next.config.ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  experimental: {
    ppr: "incremental",
  },
};

export default nextConfig;
```

`'incremental'`値を使用することで、特定のルートに対してPPRを採用できます。

次に、ダッシュボードレイアウトに`experimental_ppr`セグメント設定オプションを追加します：

```typescript
// /app/dashboard/layout.tsx
import SideNav from "@/app/ui/dashboard/sidenav";

export const experimental_ppr = true;

// ...
```

これで完了です。開発環境ではアプリケーションに違いが見られないかもしれませんが、本番環境ではパフォーマンスの向上を実感できるはずです。Next.jsはルートの静的部分をプリレンダリングし、動的部分はユーザーがリクエストするまで遅延させます。

部分的プリレンダリングの素晴らしい点は、使用するためにコードを変更する必要がないことです。ルートの動的部分をSuspenseでラップしている限り、Next.jsはルートのどの部分が静的で、どの部分が動的かを認識します。

PPRは[Webアプリケーションのデフォルトレンダリングモデルになる](https://vercel.com/blog/partial-prerendering-with-next-js-creating-a-new-default-rendering-model)可能性があり、静的サイトと動的レンダリングの最良の部分を組み合わせると信じています。ただし、これはまだ実験的機能です。将来的に安定化させ、Next.jsでの構築のデフォルト方法にすることを目指しています。

これらの変更を元に戻して、次の章に進むことができます。

## まとめ

これまでに、アプリケーションでのデータ取得を最適化するために、いくつかのことを行いました：

1. サーバーとデータベース間の遅延を減らすために、アプリケーションコードと同じリージョンにデータベースを作成しました
2. React Server Componentsを使用してサーバーでデータを取得しました。これにより、高コストなデータ取得とロジックをサーバーに保持し、クライアントサイドのJavaScriptバンドルを削減し、データベースのシークレットがクライアントに公開されることを防ぎます
3. SQLを使用して必要なデータのみを取得し、各リクエストで転送されるデータ量と、メモリ内でデータを変換するために必要なJavaScriptの量を削減しました
4. 意味のある場所では、JavaScriptを使用してデータ取得を並列化しました
5. 遅いデータリクエストがページ全体をブロックするのを防ぐためにストリーミングを実装し、すべてが読み込まれるのを待たずにユーザーがUIとのインタラクションを開始できるようにしました
6. データ取得を必要とするコンポーネントに移動し、ルートのどの部分が動的であるべきかを分離しました

次の章では、データを取得する際に実装する必要があるかもしれない2つの一般的なパターンについて見ていきます：検索とページネーションです。

## 第10章を完了しました

Next.js 14で導入された新しいレンダリングモデルである部分的プリレンダリングについて学習しました。

### 次へ

**第11章：検索とページネーションの追加**

Next.js APIを使用して検索とページネーションを実装する方法を学習します。
