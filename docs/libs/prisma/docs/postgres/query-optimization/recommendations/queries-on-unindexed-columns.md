# インデックスのないカラムでのクエリ

Optimizeは、データベースインデックスの欠落によって引き起こされるパフォーマンス問題を特定して解決するのに役立つ推奨事項を提供します。

## クエリ例

```
await prisma.user.findFirst({
  where: {
    name: "Marc"
  }
})

await prisma.user.findFirst({
  where: {
    name: "Jon"
  }
})

await prisma.user.count({
  where: {
    name: "Nikolas"
  }
})
```

## 何が問題なのか？

インデックスを使用すると、本のインデックスがすべてのページを読まずに情報を見つけるのに役立つのと同様に、データベースはデータをより迅速に取得できます。

インデックスなしで`where`プロパティを使用してPrismaを使用すると、データベースはテーブル内のすべての行をスキャンする必要がある場合があります（_「フルテーブルスキャン」_）、これは望ましくない可能性があります。

### ユーザーエクスペリエンス

大規模なデータセットの場合、データベースが一致する行を見つけるためにテーブル全体をスキャンする必要がある場合、ユーザーはより長い待機時間を経験します。

### リソース利用

- **高CPU使用率:** 大きなテーブルをスキャンすると、CPU使用率が大幅に増加する可能性があります
- **メモリ消費:** フルテーブルスキャン中にデータを処理および保存するには、より多くのメモリが必要です
- **ディスクI/O:** フルテーブルスキャンはディスク入出力操作を増加させます

> 警告: これらの問題は、小さなデータセットのため開発中には現れない可能性がありますが、本番環境では重大な問題になる可能性があります。

## データベースインデックスの詳細

### インデックスの仕組み

インデックスは、インデックス付きカラムの値をテーブル内の対応する行へのポインタとともに保存するデータ構造を作成します。インデックス付きカラムを使用してデータベースをクエリすると、データベースはテーブル全体をスキャンする代わりに、このインデックスを使用して関連する行を迅速に見つけることができます。

### インデックス作成のトレードオフ

- **スペースと時間:** インデックス作成には追加のストレージスペースが必要ですが、データ取得を大幅に高速化します
- **更新オーバーヘッド:** インデックスは書き込み操作にオーバーヘッドを追加します

### インデックスを使用するタイミング

- **大規模なデータセット**
- **フィルタリングまたはソートを伴う頻繁なクエリ**
- **関連データの検索**

### インデックスを使用しないタイミング

- **小さなテーブル**
- **書き込みが多いテーブル**
- **頻繁にアクセスされないテーブル**
- **大きなデータを含むカラム**
